export const title = "Writing a OLED Display Driver in Typescript + Contributing it to Open Source";
export const date = "26 Sep 2023";
export const peek = "";
export const published = true;

# {title}

### Intro

During my first year of university, my father gave me a Raspberry Pi 3B as a gift.
I loved it, it was the perfect complimentary gift to my CS degree.

But, I can still clearly recall the day I accidentally fried it when a loose jumper cable made contact with its circuit board...

I stared at it in disbelief, reconnecting the power cable, telling myself "its just a small malfunction, nothing to worry about".

But alas, it did not come back to life. It was dead.   
Sadness turned into anger a few years later when Raspberry Pis nearly surpassed bitcoin in value due to shortages...

Anyway, what was notable of that moment was that I just got a LCD1602 to work with the Pi.
The Dunning-Kruger effect was strong at first when I opened the LCD's datasheet and thought, this is it, I'd be using it in no time.

Wrong.

Not understating a word, I soon downloaded a driver someone else wrote which worked perfectly.

But what stuck with me was a deep admiration for the people trained in the mystical art of reading a datasheet, understanding it,
and implementing a working driver according to its specifications.

### Devicescript

I stumbled upon Devicescript a few months ago and was intrigued. 
Typescript on micro controllers?
Native JSON? 
Support for JSX?

It sounded good, so I decided to try it out. I wanted to see how Typescript compares to C++ in a environment dominated by it.
After a few experiments and getting the hang of things, I realized... I was having a blast.

The project has been thought out really well, and it is chock full of interesting ideas.
I would urge anyone to give it a shot and make up their own mind about it.

But moving on to the display driver for now.

I have a small SH1106 OLED display that I wanted to try with devicescript, using JSX with it sounded cool.
But like any other platform, a driver is required to communicate with peripherals such as a screen.
One such non existent driver was one for the SH1106.
So wanting to know more about the I2C protocol and how to write drivers, I decided to give it my best shot.

I did not spontaneously decide to write a driver for it, no, it took a while for the idea to fester. 
I first had to get over the self instilled fear of looking at datasheets.

What helped with that was the fact that a good driver already existed for the SH1106, written in C++ for the Arduino platform,
so I started by studying that.

{/* Reverse Engineering  */}
### gnireenignE esreveR

I had a great interest in the I2C protocol as I used it in most of my prior micro controller projects, 
but I did not know how it works on a fundamental level, and I really like knowing the inner workings of stuff.
The same with drivers, so learning to write a driver that uses I2C was like killing two birds with one stone.

#### I2C

First, what is I2C exactly?

Each pin on a micro controller can be used to do something. 
They can be setup in such a way to control external components outside the micro controller.
A button for instance, requires one pin, a basic LCD1602 requires about 6 pins.

If each and every external component requires their own exclusive pins, you'll eventually run out of pins on the microcontroller.

Thankfully, back in 1982 some smart guys at Siemens were sitting with this exact predicament and they came up with I2C to solve their problem.

I2C allows up to 127 devices to communicate using only 2 pins. 
In other words, there are only 2 wires and each device wanting to communicate connects to these 2 wires using only 2 of their own pins.

SO that LCD1602 of earlier? Slap a I2C backplate on it and bring the wires down to 2.
Or, if you want to add another I2C device to expand the microcontroller's capabilities, simply connect it to the wires.

As you can see, I2C is a extremely useful protocol and knowing how it works can be quite beneficial.

So why only up to 127 devices on the wire? And how can each device be controlled individually?








